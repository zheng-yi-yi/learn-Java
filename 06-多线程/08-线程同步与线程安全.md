# 线程同步与线程安全

## 线程同步

在Java中，我们可以通过`synchronized`关键字实现线程同步。

> `synchronized`通常用于保护数据的一致性和防止数据竞争。例如，当多个线程需要修改同一个数据时，我们可以使用`synchronized`来确保每次只有一个线程可以修改数据，从而保证数据的一致性。

### （1）基本使用

`synchronized`可以修饰方法或者作为代码块的一部分。

当一个线程访问`synchronized`修饰的方法或代码块时，它会获取一个锁，其他试图访问这个方法或代码块的线程将会被阻塞，直到锁被释放。

下面两种写法等价：

```java
public synchronized void synchronizedMethod() { // 锁住this
    // ...
}
// 解锁

public void synchronizedMethod() {
    synchronized(this) { // 锁住this
        // ...
    }
}
// 解锁
```

那如果对一个静态方法添加`synchronized`修饰符，它锁住的是哪个对象？

```java
public class MyClass {
    public static synchronized void synchronizedMethod() {
        // ...
    }
}
```

### （2）修饰静态方法

静态方法的同步机制是通过**类对象**进行的。

任何一个类都有一个由`JVM`自动创建的`Class`实例，因此，对`static`方法添加`synchronized`，锁住的是该类的`Class`实例。

当一个线程访问一个类的`synchronized`静态方法时，它会获取到这个类的锁，其他线程无法访问这个类的其他`synchronized`静态方法，直到锁被释放。

> 小结：静态方法不依赖于类的实例，其线程安全是通过锁住类的`Class`对象来实现。

## 线程安全

### （1）什么是线程安全

线程安全是指在多线程环境下，一个方法或类的实例可以被多个线程共享，且不会出现数据不一致或者行为不可预测的情况。

如果一个类被设计为允许多线程正确访问，我们就说这个类就是“线程安全”的（*thread-safe*）。

### （2）实现策略

线程安全的具体实现策略是：

1. 互斥同步：最基本的策略，包括方法同步和代码块同步。
2. 非阻塞同步：通过并发原子类来实现。
3. 无同步方案：如果一个类本身就是线程安全的，或者状态不可变，就不需要额外的同步措施。

### （3）如何设计线程安全的类

设计线程安全的类需要考虑以下几点：

1. 尽量将数据封装在对象内部，减少数据共享。
2. 对共享的数据进行访问控制，例如使用`synchronized`进行同步。
3. 避免在持有锁的情况下调用其他对象的方法。
